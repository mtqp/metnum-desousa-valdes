%********************************************************************************************
%								COMANDOS ÚTILES PARA LATEX EN ESTE TP							
%
%	\ : espacio simple
%	\\ : nueva línea
%	\par : va a la línea de abajo y deja sangría
%	\vspace{##tamaño en pt##} o \vspace{\baselineskip} en general:
%								 para dejar un espacio vertical
%	\textbf{text} :text en negrita
%	\textit{text} :text en itálica
%
% GRAFICOS CENTRADOS:
%	\begin{center}
%		\includegraphics[width=\textwidth]{./img/##ruta imagen (no hace falta extension)##}
%	\end{center}
%		--> se pueden agregar atributos como scale por si se hace muy grande
%
% TABLAS CENTRADAS:
%	\begin{center}
%	\begin{tabular}{|c|c|}
%	\hline
%	\ \textbf{Programa} & \textbf{Ticks} \\
%	\hline
%		ASM & 675127609 \\
%	\hline
%	\end{tabular}
%	\end{center}
%
% ALGORITMOS (EN VARIOS LENGUAJES):
% \begin{lstlisting}
%	void sumoDiez(int &num)
%	{
%	    num += 10;
%	}
%	
%	int main()
%	{
% 	   int i;
%	    int numeroAProcesar = 20;
%	    for (i = 0; i < 50; i++)
%	    {
%	        sumoDiez(numeroAProcesar);	//Proceso el numero en cada ciclo
%	    } 
%	    return 0;
%	}
%	\end{lstlisting}
%
% para info sobre todo lo que tiene el package detallado:
% http://en.wikibooks.org/wiki/LaTeX/Source\_Code\_Listings
%
%********************************************************************************************

\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc} % para poder usar tildes en archivos UTF-8
\usepackage[spanish]{babel} % para que comandos como \today den el resultado en castellano
\usepackage{a4wide} % márgenes un poco más anchos que lo usual
%\usepackage{geometry}

%\usepackage{layout}

%\geometry{
%  includeheadfoot,
%  margin=2.7cm
%}

\usepackage[conEntregas]{caratula}
\usepackage{amssymb}
\usepackage{fancybox}
\usepackage[usenames,dvipsnames]{color}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{clrscode3e}
\usepackage{xcolor}
\usepackage{amsmath}


\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{blue},
  stringstyle=\color{orange},
}

\lstset{escapechar=@,style=customc}

\begin{document}

\titulo{Trabajo Práctico 1}
\subtitulo{Monkey Island [Primera entrega]}

\fecha{\today}

\materia{Métodos Numéricos}
\grupo{Grupo Autodenominado "Los Pichis"}

\integrante{De Sousa Bispo, Germán Edgardo}{359/12}{german\_nba11@hotmail.com}
\integrante{De Sousa Bispo, Mariano Edgardo}{389/08}{marian\_sabianaa@hotmail.com}
\integrante{Valdés Castro, Tobías}{800/12}{tobias.vc@hotmail.com}


\maketitle

\tableofcontents
\newpage

\section*{Introducción}
\addcontentsline{toc}{section}{Introducción}

El problema que se nos presentó es el del capitán Guybrush Threepwood (un gran pirata) y su barco ``El Pepino Marino''. La existencia de las raras sanguijuelas mutantes ocasiona malestar a nuestro estimado capitán. Las mismas se adhieren al parabrisas de la nave y generan temperatura que pone en peligro la integridad del mismo. La transmisión del calor por parte de las sanguijuelas se produce de manera circular y la temperatura es idéntica para todas ellas. 
\par 
El parabrisas no es invencible: si la temperatura en su punto central supera los 235 grados centígrados, las sanguijuelas ganan y el parabrisas se rompe, dejando al capitán Guybrush Threepwood a la merced de las alimañas mutantes. A este punto central se lo denominará \textit{punto crítico}.
\par 
Sin embargo, el parabrisas posee un mecanismo de defensa ante las criaturas. Los bordes emiten temperaturas bajo cero, para permitir el enfriamiento y así vencer a las sanguijuelas. El sistema de refrigeramiento emite -100$^{o}$C en todo el borde del parabrisas, disminuyendo de esta forma la temperatura global de la superficie. 
\par 
A su vez, nuestro querido capitán Threepwood posee un pollo de hule (el arma más temible para las criaturas de los Siete Mares) con el cual puede destruir sanguijuelas. Sin embargo, el uso del ``Gran Pollo'' es agotador para Guybrush, por lo que debe intentar utilizarlo la menor cantidad de veces posibles para no comprometer el resultado de la misión. 

\vspace{\baselineskip}
\par 
Es nuestro deber, como aspirantes a piratas (informáticos), ayudar al capitán Threepwood para determinar la temperatura en el punto crítico y saber si es necesario utilizar el pollo de hule para matar a las malvadas sanguijuelas. Para ello, llevamos la situación al mundo de la Computación: ya que no podemos representar los infinitos puntos que forman el parabrisas, utilizaremos una discretización que nos permitirá computar la resolución a este problema. 
\par
Gracias a las fórmulas otorgadas por la cátedra para obtener la temperatura en cada punto del parabrisas, calcularla en el punto crítico implica saber además \textit{la temperatura en todos los otros puntos}. Es por esto que encontrar una solución al problema se traduce a \textit{plantear y resolver un sistema lineal en el que las incógnitas son las temperaturas de cada posición discreta del parabrisas}. Es decir, matemáticamente, queremos encontrar una solución a la ecuación

\[ Ax = b \]

donde $x$ representa el vector con todas las temperaturas punto a punto del parabrisas discretizado. Esto nos obliga entonces a pensar qué son la matriz $A$ y el vector $b$ en esta ecuación, lo cual será explicado en la sección \textbf{Desarrollo}. Para resolver este sistema se deberá utilizar la técnica de \textbf{\textit{Eliminación Gaussiana}} a fin de obtener una matriz triangular superior. Luego, se aplicará un algoritmo de resolución llamado \textbf{\textit{backward substitution}} que se encargará de devolvernos todas las temperaturas de los puntos que hayamos podido discretizar, pudiendo así completar la misión del capitán.

\section{Desarrollo}

\subsection{Ideas y pseudocódigo}

\subsubsection{Pseudocódigo y características generales del problema}

Para comenzar a resolver este problema nos toca pensar un pseudocódigo muy simple que nos sirva de boceto general del problema; crear las matrices, resolver el sistema que queda y ubicar la información donde corresponda:

\vspace{\baselineskip}
\begin{codebox}
\Procname{$\proc{SavingPirateGuybrush}()$}
\li createAllMatricesAndVectors()
\li resolveLinearSystemEquations()
\li putNewInformationInWindshieldMatrix();
\End
\end{codebox} 
\vspace{\baselineskip}
\par

Podemos extender un poco este pseudocódigo, sabiendo que debemos crear la matriz del parabrisas, la matriz $A$ y el vector $b$ y la resolución del sistema que quede se realiza con \textit{eliminación gaussiana} y \textit{backward substitution}:

\vspace{\baselineskip}
\begin{codebox}
\Procname{$\proc{SavingPirateGuybrush}()$}
\li matrix \id{pb\_matrix} = createPBMatrix()
\li matrix \id A = createMatrixA()
\li vector \id b = createVectorB()
\li matrix \id C = gaussianElimination(\id A, \id B)
\li vector \id{resolvedX} = resolveUpperTriangularMatrix(C)
\li recreatePBMatrix(\id{pb\_matrix});
\End
\end{codebox} 
\vspace{\baselineskip}

Asumimos aquí que en cada una de esas funciones tenemos acceso a los parámetros del problema para tener una lectura más simple del pseudicódigo. Básicamente, se crean las matrices y vectores necesarios definiendo sus dimensiones, agregando información de bordes, sanguijuelas, etc., y se resuelve el sistema triangulando con $gaussianElimination(A,B)$ (utiliza una matriz aumentada $A|B$) y con $resolveUpperTriangluarMatrix(C)$ la cual aplica \textit{backward substitution}. Luego se reconstruye la matriz del parabrisas. Pasemos ahora a detallar un poco las ideas para saber qué es $A$ y qué es $b$.

\vspace{\baselineskip}

Como vimos en la introducción, resolver este problema es resolver el problema de $Ax = b$ siendo $x$ las temperaturas en todos los puntos que se hayan podido discretizar del parabrisas. Este vector $x$ tendrá un tamaño de $(n+1) \times (m+1)$ siendo $n+1$ la cantidad de filas de esa matriz y $m+1$ la cantidad de columnas. Estos $n$ y $m$ se despejan de las ecuaciones $a = m \times h$ y $b = n \times h$, es decir, $m = \frac{a}{h}$ y $n = \frac{b}{h}$ donde $a$ es el ancho del parabrisas, $b$ el alto, y $h$ siendo la discretización elegida. 

Veremos ahora qué fue lo que pensamos para determinar $b$, y luego en dos secciones distintas explicaremos las ideas atrás de las dos posibles implementaciones de la matriz $A$. Igualmente para $A$ en ambas implementaciones, queremos que $Ax = b$ sea una multiplicación realizable, luego en principio necesitamos una matriz de alto $(n+1) \times (m+1)$  (el mismo que $x$) ya que si no \textit{no podríamos hacer la multiplicación $Ax$}.

\vspace{\baselineskip}

\vspace{\baselineskip}

{\large \textbf{ $\rhd$ Vector $b$:}}

\vspace{\baselineskip}

 Teniendo en cuenta la siguiente fórmula para el cálculo de temperaturas

\[
\frac{\partial^2T(x,y)}{\partial x^{2}}+\frac{\partial^2 T(x,y)}{\partial y^{2}} \ \cong \ \frac{ t_{i-1,j} + t_{i+1,j} - 4t_{i,j} + t_{i,j-1} + t_{i,j+1}}{h^2} = 0,
\]

que los puntos de los bordes tienen temperatura fija -100${}^o$C y que los puntos afectados por el radio de ataque de las sanguijuelas valen otra temperatura fijada $t_{sang}$ en los parámetros del problema, podemos plantear a $b$ como el vector que sigue esta función partida para cada posición ($i,j$) de la matriz discreta del parabrisas:

$$f_{b}(i,j) = \left\{
\begin{array}{c l}
 -100 & si \ la \ posicion  \ p_{i,j} \ es  \ un \ borde  \ del \ parabrisas\\
 t_{sang} & si \ la \ posicion  \ p_{i,j} \ es \ afectada \ por \ una \ sanguijuela \\
 0 & en \ otro \ caso \ en \ el \ cual \ no \ conozca \ la \ temperatura \ en \ p_{i,j}
\end{array}
\right.
$$

De esta forma, el vector $b$ tendrá un tamaño igual a la cantidad de elementos de la matriz que representa al parabrisas, es decir $(n+1) \times (m+1)$, al igual que el vector $x$.

\subsubsection{Ideas para la implementación con matriz A cuadrada}

Nos queda definir entonces qué es la matriz $A$. Decidimos entonces tener una matriz cuadrada de  $((n+1) \times (m+1)) \times  ((n+1) \times (m+1))$ en la cual cada fila representa un elemento de la matriz discreta del parabrisas. Por ejemplo, la primera fila representaría al elemento (0,0), la segunda al (0,1), la tercera al (0,2), hasta la última que representa al elemento ($n-1,n-1$). A su vez, hay una misma cantidad de columnas para poder multiplicar esta matriz por $x$.

La idea atrás de esto es que, al hacer $Ax$, tengamos \textbf{un sistema de ecuaciones que incluya la derivada parcial simplificada} (que aparecía cuando no se conoce la temperatura de un punto en particular) e igualdades directas como la temperatura en los bordes o en un punto afectado. Para lograr esto, esta matriz se va a componer principalmente de \textit{ceros y unos}.

\vspace{\baselineskip}

Este sería un ejemplo de lo que queremos llevar a cabo: si en la primera fila pongo el primer elemento en 1 y el resto en 0, al multiplicar por el vector de temperaturas-incógnitas estaría teniendo en mi ecuación el valor de $x_1$. Como particularmente la primera posición de la matriz representa a un borde, en $b$ tendría según la función ya presentada un -100 indicando la temperatura fija adecuada. Luego mi ecuación sería $x_1 = -100$, y esto es justo lo que queremos. Para la siguiente temperatura me ubicaria en la segunda fila, y como esta también representa a un borde, debería colocar un $1$ en la segunda posición de la fila, así al multiplicar obtendría el $x_2 = -100$. Luego, para cada fila, voy a mirar el elemento que pertenece a la diagonal de la matriz cuadrada ya que allí se encontrará la temperatura a calcular asociada a esa posición en $x$.

En un caso más complicado como en el de temperatura desconocida, deberíamos poner $1$ en cada lugar correspondiente a $t_{i-1,j}$, $t_{i+1,j}$, $t_{i,j-1}$ y $t_{i,j+1}$ involucrado en la ecuación de la derivada segunda simplificada, y un -4 en $t_{i,j}$. Para que esos valores de $x$ aparezcan en la ecuación, ubicamos los valores en la fila de la matriz A de la siguiente forma: para $t_{i,j}$ simplemente tomo la posición ($i,i$) y coloco allí un -4 (ya que ese es su coeficiente asignado en la ecuación de la derivada parcial simplificada). Para $t_{i,j-1}$ y $t_{i,j+1}$, como solo se cambia una columna, estarán una posición menos o más en $x$, por lo tanto debo poner un 1 a ambos costados del -4. Luego, los siguientes 1 estarán a $(n+1)$ (para tener $t_{i-1,j}$) o $-(n+1)$ (para tener $t_{i+1,j}$) espacios a los costados del -4, ya que $n+1$ es el ancho de la matriz del parabrisas discreto, y al cambiar una fila en la matriz discreta del parabrisas, voy a correrme exactamente $n+1$ espacios para la izquierda o la derecha en la fila de la matriz A.

\vspace{\baselineskip}

\vspace{\baselineskip}

{\large \textbf{ $\rhd$ Un posible ejemplo para este problema:}}

\vspace{\baselineskip}

Veamos un ejemplo para una matriz pequeña como un parabrisas de $2 \times 2$ con discretización 1, sin sanguijuelas. Como habíamos dicho, la matriz discretizada del parabrisas será de tamaño $(n+1) \times (m+1)$, luego de $3 \times 3$ en este ejemplo. Así sería la matriz discreta del parabrisas, la cual llamamos $pb\_matrix$: 

\vspace{\baselineskip}

\[ pb\_matrix = \left( \begin{array}{ccc}
-100 & -100 & -100 \\
-100 & ??? & -100 \\
-100 & -100 & -100 
\end{array} \right)\] 

\vspace{\baselineskip}

Como los primeros y últimos 4 elementos de la matriz discreta del parabrisas son bordes, hay temperatura -100. En el medio desconocemos la temperatura.

Por otro lado, nuestra matriz $A$ tendrá dimensiones cuadradas de $((n+1) \times (m+1)) \times  ((n+1) \times (m+1))$, luego en este caso, será de $9 \times 9$.

\vspace{\baselineskip}

\[A = \left( \begin{array}{ccccccccc}
1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\
0 & 1 & 0 & 1 & -4 & 1 & 0 & 1 & 0 \\
0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\ 
0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1
\end{array} \right)\] 

\vspace{\baselineskip}

Tal como habíamos dicho, cada fila $i$ de esta matriz representa al elemento $i$ de la matriz del parabrisas (vista como un vector aplanado por filas). En la matriz del parabrisas, los elementos que pudimos completar con -100 representan a los bordes del parabrisas. Siguiendo la descripción que habíamos hecho de la matriz $A$, habrá un 1 en la posición $(i,i)$ para las filas que se correspondan con estos bordes, y el resto de las posiciones serán 0. Esto vale para toda la matriz salvo por el medio, en donde desconocemos la temperatura. Luego para la fila $4$ (empezando a contar desde 0), es decir la fila correspondiente al elemento del medio de la matriz del parabrisas, debemos llenar los casilleros con -4 y 1 según nos convenga para obtener luego de hacer $Ax$ la ecuación de la derivada parcial simplificada.

Los vectores $x$ y $b$ entonces tiene la forma siguiente:

\[ x =  \left( \begin{array}{c}
t_{0,0} \\
t_{0,1} \\
t_{0,2} \\
t_{1,0} \\
t_{1,1} \\
t_{1,2} \\
t_{2,0} \\
t_{2,1} \\
t_{2,2} \\
\end{array} \right), \  b = \left( \begin{array}{c}
-100 \\
-100 \\
-100 \\
-100 \\
0 \\
-100 \\
-100 \\
-100 \\
-100 \\
\end{array} \right)
\] 

Juntando todo nos queda entonces:

\[ Ax = b \]

$$
\left( \begin{array}{ccccccccc}
1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\
0 & 1 & 0 & 1 & -4 & 1 & 0 & 1 & 0 \\
0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\ 
0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1
\end{array} \right)	\left( \begin{array}{c}
t_{0,0} \\
t_{0,1} \\
t_{0,2} \\
t_{1,0} \\
t_{1,1} \\
t_{1,2} \\
t_{2,0} \\
t_{2,1} \\
t_{2,2} \\
\end{array} \right) = \left( \begin{array}{c}
-100 \\
-100 \\
-100 \\
-100 \\
0 \\
-100 \\
-100 \\
-100 \\
-100 \\
\end{array} \right)
$$
\par
Dejando la matriz aumentada siguiente, a la cual luego le aplicaremos la técnica de \textit{eliminación gaussiana} para triangularla y después resolverla mediante \textit{backward substitution},\texttt{ notar que la matriz es estrictamente diagonal dominante, por lo tanto se puede aplicar la eliminación gaussiana sin pivoteo}:
\vspace{\baselineskip}
$$
\left( \begin{array}{c | r}
t_{0,0} & -100\\
t_{0,1} & -100\\
t_{0,2} & -100 \\
t_{1,0} & -100\\
t_{0,1} + t_{1,0} - 4t_{1,1} + t_{1,2} + t_{2,1} & 0\\
t_{1,2} & -100\\
t_{2,0} & -100\\
t_{2,1} & -100\\
t_{2,2} & -100\\
\end{array} \right)
$$

\vspace{\baselineskip}

Después de resolver este sistema, vamos a llenar la $pb\_matrix$ antes mencionada con los nuevos valores calculados y eso es todo.

\vspace{\baselineskip}

\vspace{\baselineskip}
\par
Veremos qué sucede ahora con la implementación la matriz A banda, discutiremos las ideas principales y haremos un enfoque mucho más detallista en la parte de implementación.

\subsubsection{Ideas para la implementación con matriz A banda}

Antes que nada, la implementación con matriz banda se puede realizar por la naturaleza de la matriz A en el otro caso: al tener siempre unos en la diagonal y también algunos unos a $n+1$ espacios del centro (y todo el resto es 0), se nos forma una banda diagonal que podemos extraer de la matriz y trabajar únicamente con eso. En realidad, trabajar con todos los valores de la matriz $A$ cuadrada es ineficiente ya que la gran mayoría de los valores son 0 y por ejemplo todas las iteraciones de la \textit{eliminación gaussiana} que no tengan que ver con la banda \textit{no van a realizar ningún cambio en la matriz porque en esos lugares la matriz ya está triangulada} (son todos ceros).

Ya que el pseudocódigo presentado se mantiene incluso para esta implementación, veremos únicamente los cambios a las principales funciones y en la estructura de la matriz $A$ para que esta forma de enfrentar el problema se realice adecuadamente.

\vspace{\baselineskip}

Como ya dijimos, para esta implementación nos alcanza con tomar la banda de la matriz $A$ cuadrada. La banda tiene un tamaño de $2(n+1)+1$ elementos (desde la mitad hay $n+1$ elementos hacia ambos costados y además cuento aquel de la mitad), por lo cual la matriz $A$ modificada tendrá un tamaño de $(n+1) \times (m+1)$ filas por $2(n+1)+1$ columnas, lo cual \textit{a priori} sugiere mucho menos memoria necesaria para almacenar toda la matriz A. Sin embargo, con una matriz de este estilo estaríamos tomando \textit{casilleros de más}, ya que por ejemplo al principio y al final de la matriz, la banda tiene la mitad de su tamaño. De todas formas, para no complicar esta parte de la implementación, vamos a seguir tomando estos elementos de más y solamente los evitaremos en el resto de las funciones de triangulación y resolución del sistema que nos vaya a quedar.

	\begin{center}
		\includegraphics[scale=1]{./img/matriz_A_idea.png}
		\vspace{2pt}
		\par
		\footnotesize\textit{Aquí se puede observar la matriz A completa y la A' siendo la banda. Nótese que tanto al final como al principio de A' hay elementos que no pertenecen a la matriz cuadrada.}
	\end{center}
	
	
Ya que la idea es tomar toda la banda como una matriz, esta va a tener la particularidad de que entre dos filas consecutivas habrá una columna de diferencia en la matriz cuadrada. Por ejemplo, tomemos dos filas consecutivas $f_1$ y $f_2$ en las que sus $2(n+1)+1$ elementos existan en la matriz cuadrada. Lo que se puede destacar es que los elementos $f_1[0]$ y $f_2[0]$ en la matriz cuadrada \textit{no estarán en la misma columna}, ya que representan a alementos de la banda y la misma está inclinada diagonalmente. Mirando la matriz con las filas aumentando hacia abajo, si asumimos que $f_1$ está arriba de $f_2$, luego en nuestro modelo $f_2$ estará corrida de una fila hacia abajo y una columna hacia la derecha en la matriz cuadrada. Si tomara otra fila $f_3$, la fila consecutiva abajo de $f_2$, sabemos que entre $f_2$ y $f_3$ los elementos en la misma columna en la nueva matriz estarán corridos una columna hacia la derecha en la matriz cuadrada, y además entre $f_1$ y $f_3$ habrá \textit{dos} columnas de diferencia. He aquí un dibujo que ilustra la situación:


	\begin{center}
		\includegraphics[scale=1]{./img/matriz_A_offset.png}
		\vspace{2pt}
		\par
		\footnotesize\textit{Aquí se puede apreciar el offset real respecto a las columnas que existe entre 1 o más filas en la matriz banda A'.}
	\end{center}
	
\vspace{\baselineskip}

\vspace{\baselineskip}
\par

Con esa estructura en mente, pasamos a ver las ideas para las modificaciones de la \textit{eliminación gaussiana} y la \textit{backward substitution}. Básicamente, al aplicar \textit{eliminación gaussiana}, queremos obtener la matriz que representa a \textbf{la banda de la matriz cuadrada después de haberla triangulado}. Esto quiere decir que \textit{no queremos triangular la nueva matriz banda $A$}, sino obtener los mismos resultados de la banda en la matriz cuadrada después de triangularla. Para ello debemos lograr una correspondencia de índices que nos permita utilizar sin problemas la nueva estructura, simulando que tenemos la completa con todos los demás 0 fuera de la banda.

Lo mismo sucede con la \textit{backward substitution}: si encontramos una correspondencia entre los índices de la matriz banda y la cuadrada que logre el mismo efecto que la otra implementación pero usando solamente esa porción de cada fila perteneciente a la banda, entonces el problema está resuelto.

\vspace{\baselineskip}
Esta es entonces la idea principal atrás de este tipo de implementación. Como se puede intuir, la complejidad espacial para esta solución es menor que la otra, y veremos también que temporalmente esta implementación supera claramente a la otra (ya que se realizarían muchísimas menos iteraciones para la \textit{eliminación gaussiana} y para resolver la matriz triangular). En la sección de \textbf{Implementación} se verá entonces en detalle como se pone en marcha esta solución.

\subsection{Implementación}

\subsubsection{Características comunes entre la resolución con matriz cuadrada y con matriz banda}

El código gira entorno de una clase \texttt{Parabrisas} gracias a la cual podremos leer el input del problema para que este cree todas las matrices necesarias (método \texttt{read\_form\_input}). Una vez hecho esto, se podrán calcular las temperaturas correspondientes a los datos brindados (método \texttt{calculate\_temps}). Si quisiéramos eliminar sanguijuelas, basta con llamar al método \texttt{kill\_leech}, el cual va a eliminar la sanguijuela cuyo rango de ataque sea más cercano al punto crítico, y luego recalcular las temperaturas. También se cuenta con un método \texttt{freeOfLeeches} que indicará si quedan o no sanguijuelas en nuestro parabrisas y otro método \texttt{temperatureOnCriticalPoint} el cual nos informará la temperatura en el punto crítico. Combinando estos tres últimos métodos se puede crear entonces algún algoritmo para deshacerse de todas las alimañas mutantes que afecten directamente al centro del parabrisas. Finalmente, podemos escribir el output (es decir, las temperaturas finales de nuestro parabrisas con la cantidad de sanguijuelas que hayamos dejado) a un archivo de output especificado por parámetro en el método \texttt{write\_output}.

Al crear una instancia de la clase se le puede pasar un parámetro que indicará que tipo de implementación queremos: matriz cuadrada con \textit{eliminación gaussiana} clásica (0) o matriz banda (1). Por defecto se toma la implementación clásica.

\vspace{\baselineskip}

Esos son entonces los lineamientos generales de la clase que nos ayudará a resolver el problema propuesto. Veamos ahora la clase en mayor profundidad investigando los métodos y variables privados.

Comencemos por los párametros del problema: nuestra clase va a guardar tanto qué tipo de implementación es la deseada, el ancho como el alto del parabrisas sin discretizar, la discretización elegida, el radio de ataque de las sanguijuelas y la temperatura con la cual afectan al sistema. Además se guardará un \texttt{vector} con todas las sanguijuelas si es que hay alguna. Por comodidad nos vamos a guardar también el alto y el ancho de la matriz discretizada en las variables \texttt{discr\_height} y \texttt{discr\_width} respectivamente (que se calcularán en el método \texttt{read\_input}). Luego guardaremos punteros a nuestras matrices: la matriz discreta del parabrisas \texttt{pb\_matrix} (en una estructura auxiliar), la matriz $A$ (sea banda o no) \texttt{matrix\_A} y el vector $b$ \texttt{vector\_B}.

A fines de reducir el error númerico que aparecerá al calcular las temperaturas del sistema, tomaremos todos los datos no enteros como \texttt{double}. Estos datos sensibles son todos aquellos de las matrices y vectores que involucran al sistema, y los parámetros del problema que pertenecen al conjunto de los reales (ancho, alto, radio, temperatura, discretización y posiciones de las sanguijuelas). Además de eso, para no provocar errores debidos a \textit{stack}, todas las grandes estructuras (sobre todo matrices y vectores) serán creados en el \textit{heap}, el cual permite tanto más flexibilidad, al manejar los datos mediante punteros desde cualquier lugar del programa, como más volumen de datos permitido\footnote{Aún así, en tests \textit{muy} grandes se recibe el mensaje ``bad\_alloc'' el cual denota en este caso que hasta el espacio en el \textit{heap} ha sido excedido.}.

\vspace{\baselineskip}

En nuestra implementación también se puede ver que hacemos uso de varias estructuras auxiliares que ayudarán a desenvolver mejor el código. Estas se encuentran declaradas en el archivo \texttt{structs.h}. Algunas estructuras simples como \texttt{Point} y \texttt{PointDiscr} existen más que nada por comodidad: se podrían fácilmente implementar pares de puntos con \texttt{pair} pero accederlos con $.first$ o $.second$ lo haría muy engorroso, y no habría distinción simple entre aquellos puntos con coordenadas enteras de los que tienen coordenadas reales. Además, cuentan con otras facilidades como definir operadores de igualdad (lo cual no es trivial para la estructura \texttt{Point}, ya que al tener coordenadas reales, la igualdad se cumple si dos coordenadas son iguales con un \textit{epsilon} (EPS en el código, en los \textit{defines}) de tolerancia) y operadores de representación en el output.

Otras estructuras de más importancia son \texttt{Leech} y \texttt{PB\_Matrix}: la primera es la que va a representar una sanguijuela en nuestro sistema. Esta estructura guarda información sobre la posición real del centro de la sanguijuela en el parabrisas, luego su posición discreta en la matriz correspondiente al parabrisas y todos los puntos a los que su rango de ataque afecte. \texttt{Leech} cuenta con el método \texttt{affected\_points} el cual va a devolver un vector de \texttt{PointDiscr} vacío si es que la sanguijuela toca algún borde (borde mata sanguijuela). Ver qué puntos está afectando la sanguijuela se realiza con un simple cálculo de normas (norma 2 euclideana) y \textit{matcheando} intervalos reales y discretos\footnote{Todo el código de esta función está comentado y sirve para ver como funcionan estos cálculos vectoriales.}. Si vemos que ese vector está vacío, luego no contamos la sanguijuela en el sistema y simplemente la omitimos. La condición de ``varias sanguijuelas afectando un mismo punto no se potencian'' está implicado aquí ya que lo único que se hace al crear las matrices es ver si el punto está afectado o no por alguna sanguijuela. Por lo tanto, si hay dos o más en un mismo lugar, la temperatura sigue quedando fija, y si una muere y la otra vive, el punto en común sigue afectado por la misma temperatura, solo que por la otra sanguijuela. Al final, \textit{sólo tenemos en cuenta los puntos afectados}.

La estructura \texttt{PB\_Matrix} se va a encargar del manejo de la matriz discreta del parabrisas. Por ejemplo, podemos pedirle a alguna instancia de esta clase que nos devuelva, dado un punto ($x$,$y$) real del parabrisas, su temperatura (habiendola calculado previamente). Esta temperatura va a ser devuelta siempre, aunque es importante explicar cómo lo hace: si el punto real provisto existe en la discretización simplemente se devuelve el contenido de esa posición en la matriz discreta del parabrisas. Por el contrario si esta posición no existe allí, se devolverá \textit{el promedio de las 4 temperaturas en los puntos que rodean a esta posición que no ha podido ser discretizada}.

\vspace{\baselineskip}

Para resolver el problema, primero debemos llamar a \texttt{read\_input}. Cuando todos los parámetros del problema estén procesados, este método va a proceder a crear todas las matrices y estructuras necesarias (\texttt{createAllMatrices}). Luego debemos calcular las temperaturas (\texttt{calculate\_temps}), en donde la matriz se triangulará (\texttt{gaussianElimination}) y se resolverá el sistema triangulado (\texttt{resolveTriangularMatrix}). Después se reconstruye la matriz discreta con los nuevos valores de temperatura para cada posición (\texttt{recreateWindShield}). Finalmente eliminamos o no sanguijuelas (\texttt{kill\_leech}) e imprimimos el resultado en la salida que hayamos elegido (\texttt{write\_ouput}). La eliminación de las sanguijuelas se hará en base a qué sanguijuela es la más cercana al centro del parabrisas (distancia euclideana al punto crítico) y cual es la que más puntos afectados tiene. Una vez eliminada una sanguijuela, se recalcularán todas las matrices.

Veamos entonces las particularidades de la implementación para cada tipo de matriz $A$.


\subsubsection{Implementando la matriz A cuadrada}

Para esta implementación con matriz cuadrada los algoritmos principales no sufren modificaciones: se utiliza una \textit{eliminación gaussiana} y una \textit{backward substitution} que no cambian en nada respecto a sus correspondientes algoritmos teóricos. El método \texttt{calculate\_temps} utilizará entonces en orden los métodos privados \texttt{gaussianElimination}, luego  \texttt{resolveTriangularMatrix} y finalmente \texttt{recreateWindShield} para actualizar los valores en la matriz discreta que representa al parabrisas. Los dos primeros métodos entonces no varían en comparación a los algoritmos teóricos. El paso de actualización de filas en \texttt{gaussianElimination} se realiza gracias a otra función auxiliar \texttt{updateRowJ} en la cual se iterará por toda una fila $i$ a fin de actualizar cada elemento de la fila $j$ correspondiente. 

Sin embargo, podemos repasar los métodos involucrados en la creación de la matriz $A$: aquí se llamará a \texttt{createMatrixA}, la cual su vez llama a \texttt{addLeechAndBorderInfo}. El primer método se ocupará de asignar los $(n+1) \times (m+1)$ espacios para las filas y columnas y el segundo se encargará de introducir toda la información relativa a los bordes y a las sanguijuelas (ingresar los 1 y los -4 según corresponda). En este caso de implementación, buscamos poner 1 en las diagonales si es borde o si fue afectado el punto por una sanguijuela, y si no pondremos -4 en la diagonal y unos en donde corresponda (ver \textbf{Ideas y pseudocódigo}). Luego de este punto, se pasa a la creación del vector $b$ y a calcular las temperaturas como ya hemos explicado.

Entonces, respecto al códigos, no hay mucho más para decir en este caso.

\vspace{\baselineskip}

Pasemos a discutir las complejidades teóricas: ya que para resolver este algoritmo seguimos el pseudocódigo antes mencionado tal cual está allí, la función que más complejidad lleva es la de \textit{eliminación gaussiana}, cuyo costo es de O($p^3$), siendo en este caso $p = (n+1) \times (m+1)$. El resto de las funciones que le siguen en costo son las de creación de matrices (la creación de la matriz A tiene un costo teórico de O($p^2$) tomando el mismo $p$) y la \textit{backward substitution} (ídem, O($p^2$)). Esto nos deja entonces para resolver el problema una complejidad de peor caso O($p^3$).

En la parte de complejidad espacial, como se había visto en la sección de \textbf{Ideas y pseudocódigo}, el tamaño de mi matriz A será de $((n+1) \times (m+1) \times ((n+1) \times (m+1))$ doubles, además del vector $b$ y la matriz discreta del parabrisas $pb\_matrix$ que miden todos $(n+1) \times (m+1)$ (tamaño total de filas por columnas en la matriz o tamaño total para $b$).

Las consecuencias empíricas que tendrán estas complejidades se observarán bien al comparar esta implementación con la de la matriz banda en la sección de \textbf{Experimentación}, y adelantandonos a los resultados, veremos que esta forma de resolver el problema es \textit{poco} eficiente.

\subsubsection{Implementando la matriz A banda}

Esta implementación sufre varios cambios en gran parte de los métodos implicados en la resolución del problema. Siguiendo el pseudocódigo que nos habíamos planteado, sólo la creación del vector $b$ y la matriz discreta del parabrisas no se ven afectados por este cambio de estructura.

\vspace{\baselineskip}
Empecemos entonces discutiendo la creación de la matriz $A$. Como pudimos ver en la sección de \textbf{Ideas y pseudocódigo}, el nuevo tamaño para las columnas de esta matriz será de $2n+1$ siendo $n$ el ancho de la matriz sujeta a la discretización\footnote{Fé de erratas: en un principio habíamos escrito el tamaño como $2(n+1)+1$ lo cual es correcto ya que respeta la vieja $n$ del problema. Sin embargo por comodidad, y para poder escribir $2n+1$ elementos como el ancho final de la nueva matriz, $n$ pasaría a ser ahora para nosotros (\textit{y también varias partes del código!}) el ancho de la matriz banda, que en realidad era $n+1$ según lo definido para el problema en el enunciado del trabajo práctico.}. Por lo tanto, en el método \texttt{createMatrixA}, sólo ese tamaño habrá cambiado. Sin embargo este método también llama a\texttt{addLeechAndBorderInfo} donde se agregaba a la matriz A toda la información necesaria \textit{mirando las diagonales}. Para esta implementación, ya que decidimos que las diagonales de la matriz $A$ cuadrada se encuentren en la mitad de la nueva matriz banda, en vez de llenar con 1 en la posición ($i,i$), simplemente iremos fila por fila como antes pero llenando desde el elemento del medio (es decir, aquel de índice $(i,discr\_width)$ ). El índice $discr\_width$ en columnas es el del medio de la matriz ya que hay $2n+1$ elementos, luego los índices van de 0 a $2n$, dejando en el medio a $n$ que es $discr\_width$ en nuestro caso.

Pasamos a mirar ahora las modificaciones en la \textit{eliminación gaussiana}. Lo que se pensó mirando la nueva estructura es ver qué nos servía y qué no en la anterior matriz cuadrada. Pudimos ver que hay exactamente $n$ (de aquí en más para esta subsección $n$ será siempre el ancho de la matriz discreta) espacios hacia la derecha y la izquierda, pero más importante \textit{hay también $n$ espacios hacia arriba y hacia abajo en la matriz cuadrada} en peor caso que \textit{cubren todos los elementos que pueden ser modificados por la eliminación gaussiana}. Esto sucede ya que esos $n$ elementos que hay hacia abajo desde algún punto de la diagonal pertenecen a la banda. Saliendo de ese rango de elementos, nos salimos de la banda y \textit{fuera de la banda todos los elementos \textbf{valen 0} y los multiplicadores serán 0 para este algoritmo}, lo cual no causaría ningún cambio en las filas al hacer la operación $F_j = F_j - m_{ij}F_i$. Por lo tanto, el índice $j$ en el algoritmo de EG ya no atrevesará toda las filas, si no hasta máximo $n$. Hay puntos en los cuales no hay $n$ elementos hacia abajo, como en la parte final de la banda de la matriz cuadrada, y esos casos bordes\footnote{Ver el código para más detalles: estos casos borde causan un poco de mareo para revisar el código, sin embargo tampoco creemos que merezcan ser explicados aquí en profundidad. Nos basta con que se entienda la idea que en algunos lugares no se pueden revisar todas las filas, y en el código eso está tenido en cuenta.} se arreglan limitando este rango de $j$.

Siguiendo con la correspondencia de índices, para tomar los elementos que antes nos servían para calcular cada multiplicador $m_{ij}$, ahora debemos cambiar ciertas campos: para calcularlo, necesitamos el elemento abajo de ($i,i$) en la matriz cuadrada como numerador de la división que compone al multiplicador. Ahora, ese elemento, por el offset que existe en la nueva matriz entre cada fila (ya explicado en las secciones anteriores), son los que están en diagonal hacia la izquierda (comenzando desde la mitad) en la nueva matriz. He aquí un dibujo de esta situación:

	\begin{center}
		\includegraphics[scale=1]{./img/matriz_A_eg_change1.png}
		\vspace{2pt}
		\par
		\footnotesize\textit{Aquí se puede ver como el offset respecto a las columnas afectan la elección de los índices.}
	\end{center}
	
De la misma forma, para elegir el denominador, antes se elegía la diagonal para cada fila, ahora eso corresponde a cada posición ($i,n$) en la nueva matriz. De esta forma cambia la elección de índices para el cálculo del multiplicador. Nos falta ver los cambios para la operación de \textit{update} de filas $j$: tal como pasaba para iterar sobre las filas de la banda, ahora para cambiar las columnas sobre la banda y así modificar una fila va a tener en cuenta que la banda tiene muchos menos elementos que la matriz cuadrada, y que además hay veces que en la nueva matriz hay elementos que \textit{no existen en la matriz cuadrada}. Para lograr esta correspondencia de índices se tiene en cuenta el \textit{offset} que ya fue explicado anteriormente. Uno querrá entonces iterar por todos los elementos de las filas de la nueva matriz $A$ salvo que los elementos no existan. Para poder hacer este \textit{update} necesitamos la fila $i$ de la cual utilizamos información. Es allí entre la fila que se modifica y la que se utiliza en donde aparece el \textit{offset} mencionado. La resolución de esta correspondencia entonces se encuentra comentada en el código y es un poco más fácil de seguir teniendo en cuenta estos datos y los esquemas presentados.

Esto completa entonces la \textit{eliminación gaussiana}. Los próximos cambios se encuentran en la resolución de la matriz luego de haberla triangulado.

\vspace{\baselineskip}

Los cambios en el método \texttt{resolveTriangularMatrix} son de la misma índole que los de la \textit{eliminación gaussiana}. Sólo queremos utilizar los elementos de la banda por lo cual los índices cambiarán como corresponda. Para no seguir con las mismas argumentaciones, los invitamos a mirar el código, el cual está comentado para que se entiendan los índices que hemos colocado.
\vspace{\baselineskip}

Respecto a la complejidad teórica, analicemos el algoritmo de \textit{eliminación gaussiana}. Como se ve en el código, en este método se itera en $i$ desde 0 a \textit{$(discr\_width \times discr\_height) -1$}. Llamaremos entonces $p$ a $nm$, siendo $m$ \textit{$discr\_height$} y $n$ \textit{$discr\_width$}. Luego iteramos en $j$ $n$ veces para cada $i$ en el peor caso\footnote{En realidad es un poco menos en los bordes (para las últimas $n$ filas se itera $n-(p-i)$ veces siendo $i$ alguna de esas últimas $n$ filas) pero no hace la diferencia en matrices grandes.}. Pero a su vez, se llama al método \texttt{updateRowJ}, el cual agrega en peor caso un ciclo más entre $0$ y $2n$, lo que nos deja una complejidad O$(2n)$ para este mismo. Por lo tanto teóricamente nos queda una complejidad del orden de O($p \times n \times 2n$) $ = $ O($mn^3$). Posteriormente, la funcion \textit{resolveTriangularMatrix()} aporta O($n \times p$) (luego, aproximadamente O($mn^2$) para finalizar con otro factor $p$ en \textit{recreateWindShield()}. Como pudimos ver, el algoritmo que lleva la mayor carga es el de la EG, por lo tanto la complejidad final para el algoritmo que utiliza el formato banda de la matriz está en el orden de O($n^2p$) siendo $p = n \times m$ o lo que es lo mismo O($mn^3$). 

Comparando esta complejidad temporal con la de la otra implementación tenemos las siguientes diferencias: O($mn^3$) es la complejidad que acabamos de calcular, si la pasamos a la notación con las $n$ originales del problema (aquellas que salían de las ecuaciones de $a$ y $b$), tenemos que O($mn^3) \equiv $ O$((m+1)*(n+1)^3)$. Eso va a estar comparado entonces con $O((n+1) \times (m+1))^3$ por lo cual con eso vemos fácilmente que el algoritmo con implementación banda está ahorrándose aproximadamente $(m+1)^2$ comparaciones, lo cual dependiendo de qué sea $m$, esto puede hacer variar el tiempo del algoritmo muchísimo\footnote{Más tests deberían hacerse para confirmar esto a nivel práctico pero no es el enfoque de este trabajo práctico realizarlos, por lo tanto con esta descripción concluímos con la temática de la complejidad temporal de los algoritmos.}.

Además de disminuir la complejidad temporal, esta implementación aprovecha mejor los datos del problema y mejora también la complejidad espacial. Esto se debe a que no se almacenan muchos datos que no son importantes ni aportan a la resolución del problema (como lo son los números cero por debajo y por encima de la banda). De esta manera se almacenan todos los elementos correspondientes a la banda disminuyendo el espacio ocupado en comparación con la otra implementación.

\subsubsection{Problemas en la Implementación}

\par 
Durante la realización de la implementación surgieron ciertos problemas y dificultades que hubo que sortear. Para empezar, se dificultó el diseño del código, el cual fue modificado en varias ocasiones a fin de obtener lo que realmente estabamos esperando. A su vez, realizamos la implementación intuitiva sin tener en cuenta la posterior adaptabilidad del código a la utilización de la matriz banda. Es por esto que, a pesar del correcto funcionamiento del programa, la implementación es desprolija y provocó dificultades a la hora de debuggear. Por cuestiones de tiempo, no pudimos mejorar el código para solucionar esta problemática utilizando una jerarquía de clasificación. Sin embargo, es un punto que se tendrá en cuenta para próximas implementaciones.

Por otro lado, a la hora de realizar la discretización de la posición de las sanguijuelas en el parabrisas a una posición en la matriz, nos equivocamos al tomar el rango de ataque en el eje $x$ como el rango de ataque \textit{para las filas}. Más tarde nos dimos cuenta que, para dar un ejemplo, la posición afectada (2,7) con 600$^o$C en nuestro output correspondía a la posición (7,2) de la matriz (en caso de que la granularidad sea la correspondiente). De esta forma, el eje $y$ y $x$ se intercambiaban solamente para agregar los puntos afectados por lo cual casi todos los valores estaban mal. Nos dimos cuenta al invertir los índices del método que escribe el archivo de salida, pero una vez arreglado este problema, el programa comenzó a funcionar bien, aunque no sabíamos realmente por qué, hasta que descubrimos el descuido.

Otro problema que ya fue mencionado en las secciones anteriores es el de casos de test de matrices grandes con granularidad alta (es decir, con valor para $h$ muy bajo): los \textit{allocs} que se realizaban eran tantos que superaban el límite de capacidad del \textit{heap} y nos devolvía un mensaje de error \textit{bad\_alloc} (hemos visto hasta más de 1.31 Gb en \textit{allocs}). Esto nos imposibilitó algunos tests con la matriz cuadrada y no así con la matriz banda, sin poder dejar una comparación para esos casos (además de trabar todo [\textit{thrashing?}] hasta que apareciera el \textit{garbage collector} del SO ya que aparentemente al dar ese error no se ejecutan los destructores y la memoria queda alojada).

A pesar de lo mencionado previamente, no tuvimos problemas de precisión a la hora de correr los tests brindados por la cátedra. Esto se debió a que desde un primer momento tuvimos cuidado de no cometer los errores presentados en clase. 


\subsection{Experimentación}
\subsubsection{Funcionamiento de Eliminación de Sanguijuelas}
	En esta sección utilizaremos distintos gráficos para detallar los experimentos realizados. 

	Utilizamos gráficos de temperatura para validar el funcionamiento de nuestro algoritmo heurístico de eliminación de sanguijuelas. A continuación vemos el resultado del algoritmo sin eliminación, y posteriormente, el resultado con ella.

	\begin{center}
		\includegraphics[scale=0.5]{./img/test5_sinkill.png}
	\end{center}

	\begin{center}
		\includegraphics[scale=0.5]{./img/test5_conkill.png}
	\end{center}

	Como ya mencionamos, la heurística consta de eliminar las sanguijuelas más cercanas al centro del parabrisas hasta que el punto crítico sea menor al umbral. En este ejemplo, se eliminaron 3 sanguijuelas para lograr el objetivo.

	Este algoritmo posee como caso borde que las sanguijuelas se encuentren equidistantes con el centro del parabrisas. Los siguientes dos gráficos muestras el algoritmo sin y con eliminación respectivamente. La desición sobre qué sanguijuela eliminar es arbitraria y depende de cómo fue instanciado.

	\begin{center}
		\includegraphics[scale=0.5]{./img/test6_sinkill.png}
	\end{center}

	\begin{center}
		\includegraphics[scale=0.5]{./img/test6_conkill.png}
	\end{center}

	En nuestro caso, la sanguijuela izquierda fue eliminada.

	Cabe destacar que no siempre el resultado es el óptimo, es decir, no siempre se minimiza la cantidad de sanguijuelas removidas. Si tenemos un caso donde las sanguijuelas están equidistantes al centro del parabrisas, no se contabiliza en la decisión de remoción la distancia al borde del parabrisas. El frío que emana de los bordes influye significativamente en el impacto que la sanguijuela tiene en el centro.

\subsubsection{Experimento de Granularidad y Temperatura}

	Los tests anteriores poseen granularidad fija. Para vislumbrar cuál es el impacto de modificarla, utilizaremos nuevamente gráficos de temperatura. En todos los gráficos fijamos el tamaño del parabrisas (400 metros por 400 metros), la cantidad de sanguijuelas (una); y su temperatura (400 grados).

	\begin{center}
		\includegraphics[scale=0.5]{./img/granularidad/g50_t400_sinkill.png}
	\end{center}

	El valor de temperatura en cada cuadrado de 50 x 50 es marcado, la diferencia entre bloques contiguos es muy alta. Es difícil distinguir a la sanguijuela ya que su forma no es circular.

	\begin{center}
		\includegraphics[scale=0.5]{./img/granularidad/g20_t400_sinkill.png}
	\end{center}

	La sanguijuela comienza a identificarse y se forman anillos con temperaturas decrecientes alrededor de ella. La distribución de la temperatura parece más homogénea.

	\begin{center}
		\includegraphics[scale=0.5]{./img/granularidad/g5_t400_sinkill.png}
	\end{center}

	El círculo de la sanguijuela ahora sí es completamente distinguible. Exceptuando los valores saturados, la temperatura a nivel global (y en el centro del parabrisas) parece aumentar. Esto puede deberse a que al tener una mayor granularidad, el algoritmo puede dispersar mejor el calor, ajustándose mejor a la realidad.

	\begin{center}
		\includegraphics[scale=0.5]{./img/granularidad/g1_t400_sinkill.png}
	\end{center}

	La buena resolución de este gráfico permite tener una apreciación detallada sobre la dispersión de calor. Contribuye a la hipótesis: ``Cuanta más resolución, mejor dispersión de calor''. Sin embargo, como se verá posteriormente en este trabajo, existe una estrecha relación entre tiempo de cómputo y presición de los resultados. 
	
	Veamos entonces cómo cambia la temperatura en el punto central a medida que se modifica la granularidad.


	\begin{center}
		\includegraphics[scale=0.75]{./img/temp_punto_critico/temppuntocritico.png}
	\end{center}

	A medida que la granularidad es más fina la temperatura aumenta, reforzando nuestra hipóstesis. Existen granularidades como 80 y 16 los cuales no son múltiplos de 200 por lo tanto no tenemos el valor en el punto exacto. Optamos por devolver el promedio de los cuatro puntos más cercano. Esta desición modifica significativamente el valor de la temperatura en el punto crítico. 

	Por otro lado, la información sobre la temperatura en el centro del parabrisas comienza a ser confiable a medida que la discretización contiene más puntos. Veamos mediante gráficos de temperatura la diferencia entre 25 y 40 metros de granularidad.

	\begin{center}
		\includegraphics[scale=0.5]{./img/temp_punto_critico/granularidad25.png}
		\includegraphics[scale=0.5]{./img/temp_punto_critico/granularidad40.png}
	\end{center}

	La definición con la que se muestra afecta directamente sobre el resultado final. Resulta entonces que utilizar definición baja cuando se desconoce la topología del problema (disposición espacial de las sanguijuelas en el parabrisas) puede llevarnos a tomar desiciones incorrectas.

\newpage
\subsubsection{Experimentos de Granularidad y Tiempo}	

\par 
	Los siguientes experimentos involucran tiempos. Los mismos se corrieron en una ultrabook Exo con procesador Intel Core i7-3517U CPU @ 1.90GHz-2.40GHz, con 8GB de memoria RAM.  
	Como se mencionó con anterioridad, existe una estrecha relación entre tiempo de computo y presición de los resultados. Es por esto, que se tomó el tiempo de ejecución del algoritmo para todos los casos que se mencionaron previamente, es decir, para el parabrisas de 400 metros por 400 metros, con una sola sanguijuela que posee 400 grados como temperatura. El parámetro que fue variando fue la granularidad, de igual forma a la realizada en los gráficos de temperatura que se expusieron. Estos valores fueron 50, 30, 5 y 1. 
	\par 
	La hipótesis planteada es que mientras menor es la granularidad para un mismo parabrisas, el tiempo de cómputo aumenta. Es por esto, que se planteó correr cien iteraciones del algoritmo de resolución, con la intención de disminuir los outliers, para estos valores de granularidad  y obtener luego un promedio\footnote{Deberíamos haber visto también si el promedio era buen estimador, haciendo uso del desvío estándar por ejemplo. Faltó tiempo al final para rehacer los tests cuando nos dimos cuenta que no teníamos los resultados intermedios para calcularlo. Nos queda pendiente para el próximo trabajo a entregar.} de la suma total de los mismos. Sin embargo, esto fue posible sólo para los parabrisas con granularidad 50 y 30, ya que para aquellas granularidades menores, la resolución de cien instancias del problema contabilizaron más de 4 horas de cómputo para la matriz sin optimizar, es decir, sin aprovechar el uso de la matriz banda.
	\par 
	Es por esto, que con el objetivo de obtener más mediciones, se disminuyó la cantidad de iteraciones de resolución, disminuyendo también la precisión del experimento. Primero se intentó con 50 corridas del algoritmo, pero para la implementación con optimizaciones también demoró varias horas. De la misma manera, se redujo la cantidad de iteraciones nuevamente a 20 y posteriormente a 5 para el algoritmo que aprovecha el uso de la matriz banda. A pesar de que el algoritmo también demoró en el orden de horas para terminar, la implementación sin optimización alguna no pudo terminar \textit{una sola} corrida del algoritmo luego de más de 4 horas. 
	\par 
	Es por esto que a continuación se presenta el gráfico de granularidad respecto del tiempo con ambas implementaciones para granularidad 50 y 20, y solo la que usa la matriz banda para granularidad 5 y 1.
	\par 
	\begin{center}
		\includegraphics[scale=0.7]{./img/granularidad/granularidadrespectotiempo.png}
	\end{center}
	
	\par 
	Es necesario notar que el eje y, correspondiente a la cantidad de ciclos en promedio que demoró la resolución de las iteraciones, se encuentra en una escala logarítmica. 
	\par 
	Para ambos casos que se realizaron 100 iteraciones, es decir, para el test con granularidad 50 y el mismo con parámetro 20, la implementación que hace provecho de la matriz banda es extremadamente más rápida que aquella que no, sin siquiera tener en cuenta como disminuye la complejidad espacial. A su vez, se puede notar que a medida que disminuye la granularidad, la cantidad de ciclos por iteración del algoritmo aumenta al punto en el que no fue posible medirlo por restricciones temporales. 
	\par 
	De esta manera, la experimentación permite afirmar que la hipótesis respecto al aumento del tiempo respecto a la disminución de la granularidad es correcta y además queda explícito algo que damos por supuesto; la implementación que utiliza el hecho de ser matriz banda es mucho mejor a la implementación intuitiva de matriz, tanto espacial como temporalmente.
	
	\par 
	
\subsubsection{Comparación de Algoritmos con y sin Eliminación}
	Por último, se realizaron experimentos para medir los tiempos del mismo test para el algoritmo que permite eliminar sanguijuelas y para aquel que no. 
	Debido a la implementación realizada, el algoritmo que puede eliminar sanguijuelas simplemente repite la implementación del mismo que no permite matar a las alimañas. Es por esto que es fácil de deducir que la versión optimizada es la que va a demorar menos tiempo. 
	\par 
	Para mostrar esto, se utilizó el test3 brindado por la cátedra. A continuación se mostrará el gráfico de temperatura correspondiente al mismo sin realizar la eliminación de sanguijuelas:
	
	\begin{center}
		\includegraphics[scale=0.5]{./img/test3.png}
	\end{center}
	
	Ahora, el gráfico de temperatura del mismo test con la eliminación de sanguijuelas:
	
	\begin{center}
		\includegraphics[scale=0.5]{./img/test3_con_kil.png}
	\end{center}
	
	\par 
	Como se puede ver, el algoritmo eliminó la sanguijuela ubicada en la parte inferior izquierda. Esto implica que la cantidad de veces que realizó dos veces el algoritmo(la primera vez para calcular el parabrisas obteniendo la imagen superior y posteriormente recalculando luego de eliminar una sanguijuela). 
	\par 
	A continuación, se presentará el gráfico de tiempos correspondiente al algoritmo con eliminación de sanguijuelas comparado con el que no:
\par 	
	\begin{center}
		\includegraphics[scale=0.5]{./img/comparacionkill.png}
	\end{center}
	
	\par 
	Como se mencionó previamente, el algoritmo que hace uso de la matriz banda realiza el algoritmo en cualquiera de los dos modos (con eliminación de sanguijuelas o sin) más rápido que la otra implementación. 
	\par 
	Teniendo en cuenta que el eje y representa la cantidad de ciclos de reloj en promedio de 50 iteraciones, la diferencia de tiempos entre el algoritmo con eliminación y sin no parece tan grande. Sin embargo, al estar en una escala logarítmica, la diferencia es más pronunciada. Por ejemplo, en este caso, el promedio para el algoritmo optimizado sin eliminación es de 143135130237 ciclos de reloj en promedio, mientras que el mismo algoritmo pero matando sanguijuelas es 283591663824, el cual es aproximadamente el doble.
	
	\par 
	De esta manera, se ve que, como se dijo previamente, que el algoritmo con eliminación tarda más ciclos de reloj que el algoritmo que no se preocupa por la temperatura en el punto crítico. Además, se puede ver, tal como es esperado, que hay una relación entre cuántas sanguijuelas son eliminadas con el tiempo de ejecución del algoritmo. Es decir, cada sanguijuela que es matada corresponde aproximadamente a sumar una vez más el tiempo de ejecución del algoritmo  sin eliminación (no se puede asegurar que es el mismo tiempo, ya que se tienen que reiniciar algunas estructuras, pero si es aproximado).
	
	
	
\section{Conclusión}


	La utilizacion de sistemas de ecuaciones lineales para resolver problemas del mundo real (o virtual como video juegos) resultan ser muy útiles. Para esto, resulta importante cultivar el proceso de abstracción. En este caso, el problema original de un parabrisas con sanguijuelas pudo ser abstraído a resolver un sistema de ecuaciones lineales. 

	\par
	Resulta también muy importante en este proceso, destacar las particularidades del problema a resolver. Conocer que la matriz que modela el problema es estrictamente diagonal dominante nos asegura (al menos teóricamente) que el algoritmo sin pivoteo funciona. Si bien no fue calculado empíricamente, el número de condición de la matriz también es bajo (debido a que prácticamente es una matriz diagonal) y por lo tanto, vamos a conseguir resultados confiables. Además de poder vislumbrar la calidad del resultado, entender el problema nos ayuda también a por ejemplo: diseñar mejores soluciones desde el punto de vista de complejidad espacial/temporal. Un claro ejemplo de esto fue la implementación de la matriz banda.

	\par
	Los tests realizados mostraron una marcada relación entre tiempo de cómputo y calidad de la solución. A mayor tiempo para procesar, mejores soluciones obtenemos. Es relevante denotar que en este caso, y dada la implementación utilizada, hacer un test muy rápido con resolución baja podía darnos resultados completamente disímiles a la solución asintótica. Por otro lado, las optimizaciones espaciales fueron cruciales: como habíamos denotado al explicar los problemas que tuvimos al implementar la solución al problema, algunos tests consumieron más de un \textit{gigabyte}; otros directamente no pudieron ser corridos dado que el proceso consumía más memoria que la permitida por el sistema operativo (en Windows), granularidad menor a 1 con mapas de 400 metros cuadrados. Repetimos que las limitaciones temporales también pueden potencialmente ser un inconveniente y deben ser analizadas y tenidas en cuenta: dado que son algoritmos polinomiales, podemos descansar en que vamos a obtener una solución en una medida corta de tiempo, para alguna definición de \textit{medida corta de tiempo}. Con estas consideraciones, los gráficos muestran cómo crecen los órdenes de magnitud en cantidad de operaciones. Aún con una buena cota asintótica teórica, la resolución de algunos problemas tardaron horas, dimensiones que en contextos determinados, pueden ser inadmisibles.

	\par
	Consideramos al proceso de aprendizaje y desarrollo de software iterativo. La información relevada mediante gráficos y datos impresos en consola nos ayudó a: por un lado terminar de comprender el problema y por otro, pensar nuevas formas de optimizar los tiempos de cómputo y espacio, así como nuevos tests e intentar generar el nexo con la teoría de métodos numéricos. Resaltamos y catalogamos como \texttt{muy enriquecedor} el análisis empírico del algoritmo.

\section{Bibliografía y referencias} %arreglar cuando se termine 

\begin{itemize}
	\item \textbf{STL de C++}: \url{http://en.cppreference.com}.
%	\par Para la función \texttt{rand()}, \url{http://en.cppreference.com/w/cpp/numeric/random/rand}.
%	\par Para la función \texttt{sort()}, \url{http://en.cppreference.com/w/cpp/algorithm/sort}.
%	\item Distribución de \texttt{rand()}?, \url{http://eternallyconfuzzled.com/arts/jsw\_art\_r and.aspx}
	\item \textbf{Funciones de Métodos Numéricos:}
		\par Eliminación Gaussiana y \textit{backward substitution}: Richard BURDEN, Numerical Analysis 9th Ed. Chapter 6
	\item \textbf{Contador de clocks}: \url{http://www.mcs.anl.gov/\~kazutomo/rdtsc.html}
\end{itemize}


\end{document}
